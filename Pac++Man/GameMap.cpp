/****************************************************************************
File: GameMap.cpp
Author: fookenCode
****************************************************************************/
#include "GameMap.h"
#include <iostream>
#include <Windows.h>
#include "Constants.h"

GameMap::GameMap() {
	mapSizeY = DEFAULT_MAP_HEIGHT;
	mapSizeX = DEFAULT_MAP_WIDTH;
	totalDots = 0;
	currentLevel = 0;
	initializeMapObject();
}

/****************************************************************************
Function: initializeMapObject
Parameter(s): N/A
Output: N/A
Comments: Used internally to create the Character Map for game board.
****************************************************************************/
void GameMap::initializeMapObject() {
	char transferMapBuffer[][DEFAULT_MAP_WIDTH] = {
		// Line 1
		{ 0xC9, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xBB,
		0xC9, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xBB },
		// Line 2
		{ 0xBA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xBA,
		0xBA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xF9, 0xBA },
		// Line 3
		{ 0xBA, 0xFA, 0xDA, 0xC4, 0xC4, 0xC4, 0xBF, 0xFA, 0xDA, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xBF, 0xFA, 0xBA,
		0xBA, 0xFA, 0xDA, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xBF, 0xFA, 0xDA, 0xC4, 0xC4, 0xC4, 0xBF, 0xFA, 0xBA },
		// Line 4
		{ 0xBA, 0xFA, 0xB3, 'a', 'a', 'a', 0xB3, 0xFA, 0xB3, 'a', 'a', 'a', 'a', 'a', 0xB3, 0xFA, 0xBA, 0xBA, 0xFA, 0xB3,
		'a', 'a', 'a', 'a', 'a', 'a', 'a', 0xB3, 0xFA, 0xB3, 'a', 'a', 'a', 0xB3, 0xFA, 0xBA },
		// Line 5
		{ 0xBA, 0xFA, 0xC0, 0xC4, 0xC4, 0xC4, 0xD9, 0xFA, 0xC0, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xD9, 0xFA, 0xC8, 0xBC,
		0xFA, 0xC0, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xD9, 0xFA, 0xC0, 0xC4, 0xC4, 0xC4, 0xD9, 0xFA, 0xBA },
		// Line 6
		{ 0xBA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA,
		0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xBA },
		// Line 7
		{ 0xBA, 0xFA, 0xDA, 0xC4, 0xC4, 0xC4, 0xBF, 0xFA, 0xDA, 0xC4, 0xBF, 0xFA, 0xDA, 0xC4, 0xC4, 0xC4, 0xC4,
		0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xBF, 0xFA, 0xDA, 0xC4, 0xBF, 0xFA, 0xDA, 0xC4, 0xC4, 0xC4, 0xBF, 0xFA, 0xBA },
		// Line 8
		{ 0xBA, 0xFA, 0xB3, 'a', 'a', 'a', 0xB3, 0xFA, 0xB3, 'a', 0xB3, 0xFA, 0xC0, 0xC4, 0xC4, 0xC4, 0xBF, 'a', 0xDA,
		0xC4, 0xC4, 0xC4, 0xC4, 0xD9, 0xFA, 0xB3, 'a', 0xB3, 0xFA, 0xB3, 'a', 'a', 'a', 0xB3, 0xFA, 0xBA },
		// Line 9
		{ 0xBA, 0xFA, 0xC0, 0xC4, 0xC4, 0xC4, 0xD9, 0xFA, 0xB3, 'a', 0xB3, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xB3, 'a',
		0xB3, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xB3, 'a', 0xB3, 0xFA, 0xC0, 0xC4, 0xC4, 0xC4, 0xD9, 0xFA, 0xBA },
		// Line 10
		{ 0xBA, 0xF9, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xB3,  'a', 0xC0, 0xC4, 0xC4, 0xC4, 0xBF, ' ', 0xB3, 'a',
		0xB3, ' ', 0xDA, 0xC4, 0xC4, 0xC4, 0xC4, 0xD9, 'a', 0xB3, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xBA },
		// Line 11
		{ 0xC8, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xFA, 0xB3, 'a', 0xDA, 0xC4, 0xC4, 0xC4, 0xD9, ' ', 0xC0, 0xC4, 0xD9,
		' ', 0xC0, 0xC4, 0xC4, 0xC4, 0xC4, 0xBF, 'a', 0xB3, 0xFA, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xBC },
		// Line 12
		{ ' ', ' ', ' ', ' ', ' ', ' ', ' ', 0xFA, 0xB3, 'a', 0xB3,  ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
		' ', ' ', 0xB3, 'a', 0xB3, 0xFA, ' ', ' ', ' ', ' ', ' ', ' ', ' ' },
		// Line 13
		{ 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xBB, 0xFA, 0xB3, 'a', 0xB3, ' ', 0xDA, 0xC4, 0xC4, 0xC4, ' ', ' ', ' ', 0xC4,
		0xC4, 0xC4, 0xC4, 0xBF, ' ', 0xB3, 'a', 0xB3, 0xFA, 0xC9, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD },
		// Line 14
		{ ' ', ' ', ' ', ' ', ' ', ' ', 0xBA, 0xFA, 0xC0, 0xC4, 0xD9, ' ', 0xB3, ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
		0xB3, ' ', 0xC0, 0xC4, 0xD9, 0xFA, 0xBA, ' ', ' ', ' ', ' ', ' ', ' ' },
		// Line 15
		{ ' ', ' ', ' ', ' ', ' ', ' ', 0xBA, 0xFA, ' ', ' ', ' ', ' ', 0xB3, ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
		0xB3, ' ', ' ', ' ', ' ', 0xFA, 0xBA, ' ', ' ', ' ', ' ', ' ', ' ' },
		// Line 16
		{ 0xC9, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xBC, 0xFA, 0xDA, 0xC4, 0xBF, ' ', 0xC0, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4,
		0xC4, 0xC4, 0xC4, 0xD9, ' ', 0xDA, 0xC4, 0xBF, 0xFA, 0xC8, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xBB },
		// Line 17
		{ 0xBA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xB3, 'a', 0xB3, ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
		' ', ' ', 0xB3, 'a', 0xB3, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xBA },
		// Line 18
		{ 0xBA, 0xFA, 0xDA, 0xC4, 0xC4, 0xC4, 0xBF, 0xFA, 0xB3, 'a', 0xB3, ' ', 0xDA, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4,
		0xC4, 0xC4, 0xBF, ' ', 0xB3, 'a', 0xB3, 0xFA, 0xDA, 0xC4, 0xC4, 0xC4, 0xBF, 0xFA, 0xBA },
		// Line 19
		{ 0xBA, 0xFA, 0xB3, 'a', 'a', 'a', 0xB3, 0xFA, 0xC0, 0xC4, 0xD9, ' ', 0xC0, 0xC4, 0xC4, 0xC4, 0xBF, 'a', 0xDA, 0xC4, 0xC4, 0xC4,
		0xC4, 0xD9, ' ', 0xC0, 0xC4, 0xD9, 0xFA, 0xB3, 'a', 'a', 'a', 0xB3, 0xFA, 0xBA },
		// Line 20
		{ 0xBA, 0xFA, 0xB3, 'a', 'a', 'a', 0xB3, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xB3, 'a', 0xB3, 0xFA, 0xFA, 0xFA,
		0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xB3, 'a', 'a', 'a', 0xB3, 0xFA, 0xBA },
		// Line 21
		{ 0xBA, 0xFA, 0xB3, 'a', 'a', 'a', 0xB3, 0xFA, 0xDA, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xBF, 0xFA, 0xB3, 'a', 0xB3, 0xFA, 0xDA, 0xC4,
		0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xBF, 0xFA, 0xB3, 'a', 'a', 'a', 0xB3, 0xFA, 0xBA },
		// Line 22
		{ 0xBA, 0xFA, 0xC0, 0xC4, 0xBF, 'a', 0xB3, 0xFA, 0xC0, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xD9, 0xFA, 0xC0, 0xC4, 0xD9, 0xFA, 0xC0,
		0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xD9, 0xFA, 0xB3, 'a', 0xDA, 0xC4, 0xD9, 0xFA, 0xBA },
		// Line 23
		{ 0xBA, 0xFA, 0xFA, 0xFA, 0xB3, 'a', 0xB3, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 'a', 0xFA, 0xFA, 0xFA, 0xFA,
		0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xB3, 'a', 0xB3, 0xFA, 0xFA, 0xF9, 0xBA },
		// Line 24
		{ 0xC8, 0xCD, 0xBB, 0xFA, 0xB3, 'a', 0xB3, 0xFA, 0xDA, 0xC4, 0xBF, 0xFA, 0xDA, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4,
		0xC4, 0xBF, 0xFA, 0xDA, 0xC4, 0xBF, 0xFA, 0xB3, 'a', 0xB3, 0xFA, 0xC9, 0xCD, 0xBC },
		// Line 25
		{ 0xC9, 0xCD, 0xBC, 0xFA, 0xC0, 0xC4, 0xD9, 0xFA, 0xB3, 'a', 0xB3, 0xFA, 0xC0, 0xC4, 0xC4, 0xC4, 0xBF, 'a', 0xDA, 0xC4, 0xC4, 0xC4, 0xC4,
		0xD9, 0xFA, 0xB3, 'a', 0xB3, 0xFA, 0xC0, 0xC4, 0xD9, 0xFA, 0xC8, 0xCD, 0xBB },
		// Line 26
		{ 0xBA, 0xF9, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xB3, 'a', 0xB3, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xB3, 'a', 0xB3, 0xFA, 0xFA, 0xFA,
		0xFA, 0xFA, 0xFA, 0xB3, 'a', 0xB3, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xBA },
		// Line 27
		{ 0xBA, 0xFA, 0xDA, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xD9, 'a', 0xC0, 0xC4, 0xC4, 0xC4, 0xBF, 0xFA, 0xB3, 'a', 0xB3, 0xFA, 0xDA, 0xC4, 0xC4, 0xC4,
		0xC4, 0xD9, 'a', 0xC0, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xBF, 0xFA, 0xBA },
		// Line 28
		{ 0xBA, 0xFA, 0xC0, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xD9, 0xFA, 0xC0, 0xC4, 0xD9, 0xFA, 0xC0, 0xC4, 0xC4, 0xC4, 0xC4,
		0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xD9, 0xFA, 0xBA },
		// Line 29
		{ 0xBA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA,
		0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xFA, 0xBA },
		// Line 30
		{ 0xC8, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD,
		0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xCD, 0xBC },
	};

	for (int i = 0; i < mapSizeY; ++i)
	{
		strcpy_s(mapStrings[i], mapSizeX, transferMapBuffer[i]);
		strcpy_s(unalteredMapStrings[i], mapSizeX, transferMapBuffer[i]);
	}
}

/****************************************************************************
Function: isWallCharacter
Parameter(s): int - X Position within Map
              int - Y Position within Map
			  int - Enum value (See @Constants.h) for Walls to check for
Output: N/A
Comments: Used to determine if a move is possible on the Map.
****************************************************************************/
bool GameMap::isWallCharacter(int xPos, int yPos, int wallGroupToTest)
{
	char toCompare = mapStrings[yPos][xPos];
	switch (wallGroupToTest)
	{
	case INNER:
		if (toCompare == 'Ú' || toCompare == 'Ä' || toCompare == '¿' ||
			toCompare == '³' || toCompare == 'À' || toCompare == 'Ù')
		{
			return true;
		}
		break;
	case OUTER:
		if (toCompare == 'É' || toCompare == 'Í' || toCompare == '»' ||
			toCompare == 'º' || toCompare == 'È' || toCompare == '¼')
		{
			return true;
		}
		break;
	case BOTH:
		if (toCompare == 'É' || toCompare == 'Í' || toCompare == '»' ||
			toCompare == 'º' || toCompare == 'È' || toCompare == '¼' ||
			toCompare == 'Ú' || toCompare == 'Ä' || toCompare == '¿' ||
			toCompare == '³' || toCompare == 'À' || toCompare == 'Ù')
		{
			return true;
		}
		break;

	}
	return false;
}

/****************************************************************************
Function: renderMap
Parameter(s): N/A
Output: N/A
Comments: Loops over entire Map by each character position to render the 
           Map to the screen.  TODO: Support multiple levels with varying
		   colors.
****************************************************************************/
void GameMap::renderMap() {
	using namespace std;

	for (int i = 0; i < mapSizeY; ++i)
	{
		for (int j = 0; j < mapSizeX; ++j)
		{
			if (j == 0)
			{
				cout << "\t\t";
			}

			if (mapStrings[i][j] == 'ù' || mapStrings[i][j] == 'ú')
			{
				totalDots += 1;
			}

			if (isWallCharacter(j, i, BOTH) || mapStrings[i][j] == 'a')
			{
				if (mapStrings[i][j] == 'a')
					mapStrings[i][j] = ' ';
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 26);
				cout << mapStrings[i][j];
				SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 7);
			}
			else
				cout << mapStrings[i][j];
		}
		cout << endl;
	}
}

/****************************************************************************
Function: setCharacterAtPosition
Parameter(s): char - Character to enter at position specified
              int - X Position within Map
			  int - Y Position within Map
Output: N/A
Comments: Temporarily used to access the Map to edit the current tile for
          movement and interaction on the map.
****************************************************************************/
void GameMap::setCharacterAtPosition(char toEnter, int xPos, int yPos) {
	if (xPos < 0 || xPos > mapSizeX || yPos < 0 || yPos > mapSizeY) {
		return;
	}

	mapStrings[yPos][xPos] = toEnter;
}

/****************************************************************************
Function: getCharacterAtPosition
Parameter(s): int - X Position within Map
              int - Y Position within Map
Output: char - Character that exists at specified Position on Map
Comments: Temporarily used to access the Map to retrieve character
          information.
****************************************************************************/
char GameMap::getCharacterAtPosition(int xPos, int yPos) {
	if (xPos < 0 || xPos > mapSizeX || yPos < 0 || yPos > mapSizeY) {
		return ' ';
	}

	return mapStrings[yPos][xPos];
}